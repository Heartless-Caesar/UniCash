{"ast":null,"code":"import StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nfunction chunkArray() {\n  var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var size = arguments.length > 1 ? arguments[1] : undefined;\n  if (array === []) return [];\n  return array.reduce(function (acc, val) {\n    if (acc.length === 0) acc.push([]);\n    var last = acc[acc.length - 1];\n    if (last.length < size) {\n      last.push(val);\n    } else {\n      acc.push([val]);\n    }\n    return acc;\n  }, []);\n}\nfunction calculateDimensions(_ref) {\n  var itemDimension = _ref.itemDimension,\n    staticDimension = _ref.staticDimension,\n    totalDimension = _ref.totalDimension,\n    fixed = _ref.fixed,\n    spacing = _ref.spacing,\n    maxItemsPerRow = _ref.maxItemsPerRow;\n  var usableTotalDimension = staticDimension || totalDimension;\n  var availableDimension = usableTotalDimension - spacing;\n  var itemTotalDimension = Math.min(itemDimension + spacing, availableDimension);\n  var itemsPerRow = Math.min(Math.floor(availableDimension / itemTotalDimension), maxItemsPerRow || Infinity);\n  var containerDimension = availableDimension / itemsPerRow;\n  var fixedSpacing;\n  if (fixed) {\n    fixedSpacing = (totalDimension - itemDimension * itemsPerRow) / (itemsPerRow + 1);\n  }\n  return {\n    itemTotalDimension: itemTotalDimension,\n    availableDimension: availableDimension,\n    itemsPerRow: itemsPerRow,\n    containerDimension: containerDimension,\n    fixedSpacing: fixedSpacing\n  };\n}\nfunction getStyleDimensions(style) {\n  var horizontal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var space1 = 0;\n  var space2 = 0;\n  var maxStyleDimension = undefined;\n  if (style) {\n    var flatStyle = Array.isArray(style) ? StyleSheet.flatten(style) : style;\n    var sMaxDimensionXY = 'maxWidth';\n    var sPaddingXY = 'paddingHorizontal';\n    var sPadding1 = 'paddingLeft';\n    var sPadding2 = 'paddingRight';\n    if (horizontal) {\n      sMaxDimensionXY = 'maxHeight';\n      sPaddingXY = 'paddingVertical';\n      sPadding1 = 'paddingTop';\n      sPadding2 = 'paddingBottom';\n    }\n    if (flatStyle[sMaxDimensionXY] && typeof flatStyle[sMaxDimensionXY] === 'number') {\n      maxStyleDimension = flatStyle[sMaxDimensionXY];\n    }\n    var padding = flatStyle[sPaddingXY] || flatStyle.padding;\n    var padding1 = flatStyle[sPadding1] || padding || 0;\n    var padding2 = flatStyle[sPadding2] || padding || 0;\n    space1 = typeof padding1 === 'number' ? padding1 : 0;\n    space2 = typeof padding2 === 'number' ? padding2 : 0;\n  }\n  return {\n    space1: space1,\n    space2: space2,\n    maxStyleDimension: maxStyleDimension\n  };\n}\nfunction getAdjustedTotalDimensions(_ref2) {\n  var totalDimension = _ref2.totalDimension,\n    maxDimension = _ref2.maxDimension,\n    contentContainerStyle = _ref2.contentContainerStyle,\n    style = _ref2.style,\n    _ref2$horizontal = _ref2.horizontal,\n    horizontal = _ref2$horizontal === void 0 ? false : _ref2$horizontal,\n    _ref2$adjustGridToSty = _ref2.adjustGridToStyles,\n    adjustGridToStyles = _ref2$adjustGridToSty === void 0 ? false : _ref2$adjustGridToSty;\n  var componentDimension = totalDimension;\n  var actualMaxDimension = totalDimension;\n\n  if (maxDimension && totalDimension > maxDimension) {\n    actualMaxDimension = maxDimension;\n    totalDimension = maxDimension;\n  }\n  if (adjustGridToStyles) {\n    if (contentContainerStyle) {\n      var _getStyleDimensions = getStyleDimensions(contentContainerStyle, horizontal),\n        space1 = _getStyleDimensions.space1,\n        space2 = _getStyleDimensions.space2,\n        maxStyleDimension = _getStyleDimensions.maxStyleDimension;\n      if (maxStyleDimension && totalDimension > maxStyleDimension) {\n        actualMaxDimension = maxStyleDimension;\n        totalDimension = maxStyleDimension;\n      }\n      if (space1 || space2) {\n        totalDimension = totalDimension - space1 - space2;\n      }\n    }\n    if (style) {\n      var edgeSpaceDiff = (componentDimension - actualMaxDimension) / 2;\n      var _getStyleDimensions2 = getStyleDimensions(style, horizontal),\n        _space = _getStyleDimensions2.space1,\n        _space2 = _getStyleDimensions2.space2;\n      if (_space > edgeSpaceDiff) {\n        totalDimension = totalDimension - (_space - edgeSpaceDiff);\n      }\n\n      if (_space2 > edgeSpaceDiff) {\n        totalDimension = totalDimension - (_space2 - edgeSpaceDiff);\n      }\n    }\n  }\n\n  return totalDimension;\n}\nfunction generateStyles(_ref3) {\n  var itemDimension = _ref3.itemDimension,\n    containerDimension = _ref3.containerDimension,\n    spacing = _ref3.spacing,\n    fixed = _ref3.fixed,\n    horizontal = _ref3.horizontal,\n    fixedSpacing = _ref3.fixedSpacing;\n  var rowStyle = {\n    flexDirection: 'row',\n    paddingLeft: fixed ? fixedSpacing : spacing,\n    paddingBottom: spacing\n  };\n  var containerStyle = {\n    flexDirection: 'column',\n    justifyContent: 'center',\n    width: fixed ? itemDimension : containerDimension - spacing,\n    marginRight: fixed ? fixedSpacing : spacing\n  };\n  if (horizontal) {\n    rowStyle = {\n      flexDirection: 'column',\n      paddingTop: fixed ? fixedSpacing : spacing,\n      paddingRight: spacing\n    };\n    containerStyle = {\n      flexDirection: 'row',\n      justifyContent: 'center',\n      height: fixed ? itemDimension : containerDimension - spacing,\n      marginBottom: fixed ? fixedSpacing : spacing\n    };\n  }\n  return {\n    containerStyle: containerStyle,\n    rowStyle: rowStyle\n  };\n}\nexport { chunkArray, calculateDimensions, generateStyles, getAdjustedTotalDimensions };","map":{"version":3,"names":["chunkArray","array","size","reduce","acc","val","length","push","last","calculateDimensions","itemDimension","staticDimension","totalDimension","fixed","spacing","maxItemsPerRow","usableTotalDimension","availableDimension","itemTotalDimension","Math","min","itemsPerRow","floor","Infinity","containerDimension","fixedSpacing","getStyleDimensions","style","horizontal","space1","space2","maxStyleDimension","undefined","flatStyle","Array","isArray","StyleSheet","flatten","sMaxDimensionXY","sPaddingXY","sPadding1","sPadding2","padding","padding1","padding2","getAdjustedTotalDimensions","maxDimension","contentContainerStyle","adjustGridToStyles","componentDimension","actualMaxDimension","edgeSpaceDiff","generateStyles","rowStyle","flexDirection","paddingLeft","paddingBottom","containerStyle","justifyContent","width","marginRight","paddingTop","paddingRight","height","marginBottom"],"sources":["C:/Users/joaov/OneDrive/Documents/Node_Projects/UniCash/App/node_modules/react-native-super-grid/utils.js"],"sourcesContent":["import { StyleSheet } from 'react-native';\n\nfunction chunkArray(array = [], size) {\n  if (array === []) return [];\n  return array.reduce((acc, val) => {\n    if (acc.length === 0) acc.push([]);\n    const last = acc[acc.length - 1];\n    if (last.length < size) {\n      last.push(val);\n    } else {\n      acc.push([val]);\n    }\n    return acc;\n  }, []);\n}\n\nfunction calculateDimensions({\n  itemDimension,\n  staticDimension,\n  totalDimension,\n  fixed,\n  spacing,\n  maxItemsPerRow,\n}) {\n  const usableTotalDimension = staticDimension || totalDimension;\n  const availableDimension = usableTotalDimension - spacing; // One spacing extra\n  const itemTotalDimension = Math.min(itemDimension + spacing, availableDimension); // itemTotalDimension should not exceed availableDimension\n  const itemsPerRow = Math.min(Math.floor(availableDimension / itemTotalDimension), maxItemsPerRow || Infinity);\n  const containerDimension = availableDimension / itemsPerRow;\n\n  let fixedSpacing;\n  if (fixed) {\n    fixedSpacing = (totalDimension - (itemDimension * itemsPerRow)) / (itemsPerRow + 1);\n  }\n\n  return {\n    itemTotalDimension,\n    availableDimension,\n    itemsPerRow,\n    containerDimension,\n    fixedSpacing,\n  };\n}\n\nfunction getStyleDimensions(\n  style,\n  horizontal = false,\n) {\n  let space1 = 0;\n  let space2 = 0;\n  let maxStyleDimension = undefined;\n  if (style) {\n    const flatStyle = Array.isArray(style) ? StyleSheet.flatten(style) : style;\n    let sMaxDimensionXY = 'maxWidth';\n    let sPaddingXY = 'paddingHorizontal';\n    let sPadding1 = 'paddingLeft';\n    let sPadding2 = 'paddingRight';\n    if (horizontal) {\n      sMaxDimensionXY = 'maxHeight';\n      sPaddingXY = 'paddingVertical';\n      sPadding1 = 'paddingTop';\n      sPadding2 = 'paddingBottom';\n    }\n\n    if (flatStyle[sMaxDimensionXY] && typeof flatStyle[sMaxDimensionXY] === 'number') {\n      maxStyleDimension = flatStyle[sMaxDimensionXY];\n    }\n\n    const padding = flatStyle[sPaddingXY] || flatStyle.padding;\n    const padding1 = flatStyle[sPadding1] || padding || 0;\n    const padding2 = flatStyle[sPadding2] || padding || 0;\n    space1 = (typeof padding1 === 'number' ? padding1 : 0);\n    space2 = (typeof padding2 === 'number' ? padding2 : 0);\n  }\n  return { space1, space2, maxStyleDimension };\n}\n\nfunction getAdjustedTotalDimensions({\n  totalDimension,\n  maxDimension,\n  contentContainerStyle,\n  style,\n  horizontal = false,\n  adjustGridToStyles = false,\n}) {\n  const componentDimension = totalDimension; // keep track of initial max of component/screen\n  let actualMaxDimension = totalDimension; // keep track of smallest max dimension\n\n  // adjust for maxDimension prop\n  if (maxDimension && totalDimension > maxDimension) {\n    actualMaxDimension = maxDimension;\n    totalDimension = maxDimension;\n  }\n  \n  if (adjustGridToStyles) {\n    if (contentContainerStyle) {\n      const { space1, space2, maxStyleDimension } = getStyleDimensions(contentContainerStyle, horizontal);\n      // adjust for maxWidth or maxHeight in contentContainerStyle\n      if (maxStyleDimension && totalDimension > maxStyleDimension) {\n        actualMaxDimension = maxStyleDimension;\n        totalDimension = maxStyleDimension;\n      }\n      // subtract horizontal or vertical padding from totalDimension\n      if (space1 || space2) {\n        totalDimension = totalDimension - space1 - space2;\n      }\n    }\n\n    if (style) {\n      const edgeSpaceDiff = (componentDimension - actualMaxDimension) / 2; // if content is floating in middle of screen get margin on either side\n      const { space1, space2 } = getStyleDimensions(style, horizontal);\n      // only subtract if space is greater than the margin on either side\n      if (space1 > edgeSpaceDiff) {\n        totalDimension = totalDimension - (space1 - edgeSpaceDiff); // subtract the padding minus any remaining margin\n      }\n      if (space2 > edgeSpaceDiff) {\n        totalDimension = totalDimension - (space2 - edgeSpaceDiff); // subtract the padding minus any remaining margin\n      }\n    }\n  }\n\n  return totalDimension;\n}\n\nfunction generateStyles({\n  itemDimension,\n  containerDimension,\n  spacing,\n  fixed,\n  horizontal,\n  fixedSpacing,\n}) {\n  let rowStyle = {\n    flexDirection: 'row',\n    paddingLeft: fixed ? fixedSpacing : spacing,\n    paddingBottom: spacing,\n  };\n\n  let containerStyle = {\n    flexDirection: 'column',\n    justifyContent: 'center',\n    width: fixed ? itemDimension : (containerDimension - spacing),\n    marginRight: fixed ? fixedSpacing : spacing,\n  };\n\n  if (horizontal) {\n    rowStyle = {\n      flexDirection: 'column',\n      paddingTop: fixed ? fixedSpacing : spacing,\n      paddingRight: spacing,\n    };\n\n    containerStyle = {\n      flexDirection: 'row',\n      justifyContent: 'center',\n      height: fixed ? itemDimension : (containerDimension - spacing),\n      marginBottom: fixed ? fixedSpacing : spacing,\n    };\n  }\n\n  return {\n    containerStyle,\n    rowStyle,\n  };\n}\n\nexport { chunkArray, calculateDimensions, generateStyles, getAdjustedTotalDimensions };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}